const Order = require('../models/Order');
const GiftCard = require('../models/GiftCard');

exports.placeOrder = async (req, res) => {
  try {
    const { giftCardId, quantity, paymentMethod } = req.body;

    // Only accept 'whatsapp' as the payment method
    if (paymentMethod !== 'whatsapp') {
      return res.status(400).json({ message: 'Only WhatsApp payment is allowed' });
    }

    const giftCard = await GiftCard.findById(giftCardId);
    if (!giftCard) return res.status(404).json({ message: 'Gift card not found' });
    if (giftCard.stock < quantity) {
      return res.status(400).json({ message: 'Insufficient stock' });
    }

    const totalPrice = giftCard.price * quantity;

    // Decrease stock immediately
    giftCard.stock -= quantity;
    await giftCard.save();

    // Prepare order data, tailored for WhatsApp
    let orderData = {
      user: req.user._id,
      giftCard: giftCardId,
      quantity,
      totalPrice,
      paymentMethod: 'whatsapp',
      paymentReferenceCode: '', // auto-generated by Mongoose
      paymentDueDate: new Date(Date.now() + 48 * 60 * 60 * 1000), // 48h
      paymentInstructions: 'Please contact us on WhatsApp to proceed with payment and send proof.',
      status: 'pending',
      paymentStatus: 'pending_payment',
      purchasedAt: null
    };

    // Create the order first so that pre('validate') hook fills reference code
    const order = new Order(orderData);
    await order.validate();

    // Generate WhatsApp link
    const whatsappNumber = '213549000449';

    const whatsappMessage = `Hello! I have an order with Reference Code: ${order.paymentReferenceCode}. Gift Card: ${giftCard.brand}, (${giftCard.value}$), Quantity: ${quantity} Total Price: ${totalPrice}$.\nI want to proceed with payment.`;

    order.whatsappLink = `https://wa.me/${whatsappNumber}?text=${encodeURIComponent(whatsappMessage)}`;


    await order.save();

    // Respond
    return res.status(201).json({
      message: 'Order placed. Awaiting your payment proof.',
      order,
      paymentInstructions: order.paymentInstructions,
      paymentReferenceCode: order.paymentReferenceCode,
      paymentDueDate: order.paymentDueDate,
      whatsappLink: order.whatsappLink
    });
  } catch (error) {
    console.error('Place order error:', error);
    res.status(500).json({ message: 'Server error' });
  }
};


exports.getUserOrders = async (req, res) => {
  try {
    const userId = req.user._id;

    // Parse query parameters with defaults
    const page = parseInt(req.query.page, 10) || 1;
    const limit = parseInt(req.query.limit, 10) || 10;
    const startDate = req.query.startDate ? new Date(req.query.startDate) : null;
    const endDate = req.query.endDate ? new Date(req.query.endDate) : null;
    const sortField = req.query.sort || 'purchasedAt';
    const sortOrder = req.query.order === 'asc' ? 1 : -1; // descending by default

    // Build filter query
    const filter = { user: userId };

    if (startDate || endDate) {
      filter.purchasedAt = {};
      if (startDate) filter.purchasedAt.$gte = startDate;
      if (endDate) filter.purchasedAt.$lte = endDate;
    }

    // Count total filtered documents (for pagination metadata)
    const totalOrders = await Order.countDocuments(filter);

    // Fetch paginated, filtered, and sorted orders
    const orders = await Order.find(filter)
      .populate('giftCard')
      .sort({ [sortField]: sortOrder })
      .skip((page - 1) * limit)
      .limit(limit);

    res.json({
      totalOrders,       // total count for all filtered results
      totalPages: Math.ceil(totalOrders / limit),
      currentPage: page,
      orders,
    });
  } catch (error) {
    console.error("Error fetching orders:", error);
    res.status(500).json({ message: 'Server error' });
  }
};

exports.getAllOrders = async (req, res) => {
  try {
    // Pagination + sorting
    const page = parseInt(req.query.page, 10) || 1;
    const limit = parseInt(req.query.limit, 10) || 20;
    const sortField = req.query.sort || 'purchasedAt';
    const sortOrder = req.query.order === 'asc' ? 1 : -1;

    // Filters
    const startDate = req.query.startDate ? new Date(req.query.startDate) : null;
    const endDate = req.query.endDate ? new Date(req.query.endDate) : null;
    const userId = req.query.user || null;
    const giftCardId = req.query.giftCard || null;
    const referenceCode = req.query.referenceCode?.trim() || null; // NEW

    // Build query
    const filter = {};

    // Date range
    if (startDate || endDate) {
      filter.purchasedAt = {};
      if (startDate) filter.purchasedAt.$gte = startDate;
      if (endDate) filter.purchasedAt.$lte = endDate;
    }

    // Filters by related IDs
    if (userId) filter.user = userId;
    if (giftCardId) filter.giftCard = giftCardId;

    // Reference code search (case-insensitive, exact or partial)
    if (referenceCode) {
      filter.paymentReferenceCode = { $regex: new RegExp(referenceCode, 'i') };
    }

    // Count
    const totalOrders = await Order.countDocuments(filter);

    // Fetch orders
    const orders = await Order.find(filter)
      .populate('user', 'name email')
      .populate('giftCard', 'brand value')
      .sort({ [sortField]: sortOrder })
      .skip((page - 1) * limit)
      .limit(limit);

    // Respond
    res.json({
      orders,
      totalOrders,
      totalPages: Math.ceil(totalOrders / limit),
      currentPage: page,
    });

  } catch (error) {
    console.error('Error fetching orders:', error);
    res.status(500).json({ message: 'Server error' });
  }
};

exports.uploadPaymentProof = async (req, res) => {
  try {
    const { orderId } = req.params;
    const { transactionId } = req.body;
    // Assuming you're using multer for file upload middleware
    const fileUrl = req.file ? `/uploads/payments/${req.file.filename}` : null;

    const order = await Order.findById(orderId);
    if (!order) return res.status(404).json({ message: 'Order not found' });
    if (!order.user.equals(req.user._id) && req.user.role !== 'admin') {
      return res.status(403).json({ message: 'Not authorized' });
    }
    if (order.paymentStatus !== 'pending_payment' && req.user.role !== 'admin') {
      return res.status(400).json({ message: 'Payment proof not needed for this order' });
    }

    order.paymentProof = {
      url: fileUrl,
      transactionId
    };
    order.paymentStatus = 'payment_review';
    await order.save();

    res.json({ message: 'Payment proof uploaded successfully', order });
  } catch (error) {
    console.error('Upload payment proof error:', error);
    res.status(500).json({ message: 'Server error' });
  }
};

exports.verifyPayment = async (req, res) => {
  try {
    const { orderId } = req.params;
    const { status } = req.body; // 'approved' or 'rejected'

    const order = await Order.findById(orderId).populate('giftCard').populate('user');
    if (!order) return res.status(404).json({ message: 'Order not found' });

    if (status === 'approved') {
      order.paymentStatus = 'paid';
      order.status = 'completed';
      order.purchasedAt = new Date();
      order.paidAt = new Date();

      // TODO: trigger sendGiftCode(order)
    } else if (status === 'rejected') {
      order.paymentStatus = 'cancelled';
      order.status = 'cancelled';
    }

    await order.save();

    res.json({ message: `Order payment ${status}`, order });
  } catch (error) {
    console.error('Verify payment error:', error);
    res.status(500).json({ message: 'Server error' });
  }
};

exports.viewPaymentProof = async (req, res) => {
  const order = await Order.findById(req.params.orderId);
  if (!order) return res.status(404).json({ message: 'Order not found' });
  if (!order.user.equals(req.user._id) && req.user.role !== 'admin') {
    return res.status(403).json({ message: 'Not allowed' });
  }
  res.json({ paymentProof: order.paymentProof });
};