const Order = require('../models/Order');
const GiftCard = require('../models/GiftCard');

exports.placeOrder = async (req, res) => {
    try {
      const { giftCardId, quantity, paymentMethod } = req.body;
  
      if (!paymentMethod) {
        return res.status(400).json({ message: 'Payment method is required' });
      }
  
      const giftCard = await GiftCard.findById(giftCardId);
      if (!giftCard) return res.status(404).json({ message: 'Gift card not found' });
      if (giftCard.stock < quantity) {
        return res.status(400).json({ message: 'Insufficient stock' });
      }
  
      const totalPrice = giftCard.price * quantity;
  
      // Decrease stock immediately
      giftCard.stock -= quantity;
      await giftCard.save();
  
      // Prepare base data
      let orderData = {
        user: req.user._id,
        giftCard: giftCardId,
        quantity,
        totalPrice,
        paymentMethod,
        paymentReferenceCode: '', // auto-generated by Mongoose
        paymentDueDate: undefined,
        paymentInstructions: '',
        purchasedAt: null
      };
  
      if (['bank_transfer', 'baridimob', 'whatsapp'].includes(paymentMethod)) {
        orderData.status = 'pending';
        orderData.paymentStatus = 'pending_payment';
        orderData.paymentDueDate = new Date(Date.now() + 48 * 60 * 60 * 1000); // 48h
  
        if (paymentMethod === 'bank_transfer') {
          orderData.paymentInstructions = 'Send the deposit to CCP Account: 00123456789, Name: Your Company';
        } 
        else if (paymentMethod === 'baridimob') {
          orderData.paymentInstructions = 'Send the payment via BaridiMob to +213 77 123 45 67';
        }
        else if (paymentMethod === 'whatsapp') {
          orderData.paymentInstructions = 'Please contact us on WhatsApp to proceed with payment and send proof.';
        }
  
      } else {
        // ONLINE payment
        orderData.status = 'completed';
        orderData.paymentStatus = 'paid';
        orderData.purchasedAt = Date.now();
      }
  
      // Create the order first so that the pre('validate') hook generates the reference code
      const order = new Order(orderData);
      await order.validate(); // trigger pre('validate') to fill reference code
  
      // Now if it's WhatsApp, generate link with correct reference
      if (paymentMethod === 'whatsapp') {
        const whatsappNumber = '213549000449'; // International format, no '+'
        order.whatsappLink = `https://wa.me/${whatsappNumber}?text=${encodeURIComponent(
          `Hello! I have an order with Reference Code: ${order.paymentReferenceCode}. I want to proceed with payment.`
        )}`;
      }
  
      await order.save();
  
      return res.status(201).json({
        message:
          paymentMethod === 'online'
            ? 'Order placed and paid successfully'
            : 'Order placed. Awaiting your payment proof.',
        order,
        ...(paymentMethod !== 'online' && {
          paymentInstructions: order.paymentInstructions,
          paymentReferenceCode: order.paymentReferenceCode,
          paymentDueDate: order.paymentDueDate,
          ...(paymentMethod === 'whatsapp' && { whatsappLink: order.whatsappLink })
        })
      });
    } catch (error) {
      console.error('Place order error:', error);
      res.status(500).json({ message: 'Server error' });
    }
  };

exports.getUserOrders = async (req, res) => {
    try {
        const userId = req.user._id;

        // Parse query parameters with defaults
        const page = parseInt(req.query.page, 10) || 1;
        const limit = parseInt(req.query.limit, 10) || 10;
        const startDate = req.query.startDate ? new Date(req.query.startDate) : null;
        const endDate = req.query.endDate ? new Date(req.query.endDate) : null;
        const sortField = req.query.sort || 'purchasedAt';
        const sortOrder = req.query.order === 'asc' ? 1 : -1; // descending by default

        // Build filter query
        const filter = { user: userId };

        if (startDate || endDate) {
            filter.purchasedAt = {};
            if (startDate) filter.purchasedAt.$gte = startDate;
            if (endDate) filter.purchasedAt.$lte = endDate;
        }

        // Count total filtered documents (for pagination metadata)
        const totalOrders = await Order.countDocuments(filter);

        // Fetch paginated, filtered, and sorted orders
        const orders = await Order.find(filter)
            .populate('giftCard')
            .sort({ [sortField]: sortOrder })
            .skip((page - 1) * limit)
            .limit(limit);

        res.json({
            totalOrders,       // total count for all filtered results
            totalPages: Math.ceil(totalOrders / limit),
            currentPage: page,
            orders,
        });
    } catch (error) {
        console.error("Error fetching orders:", error);
        res.status(500).json({ message: 'Server error' });
    }
};

exports.getAllOrders = async (req, res) => {
    try {
      // Pagination + sorting
      const page = parseInt(req.query.page, 10) || 1;
      const limit = parseInt(req.query.limit, 10) || 20;
      const sortField = req.query.sort || 'purchasedAt';
      const sortOrder = req.query.order === 'asc' ? 1 : -1;
  
      // Filters
      const startDate = req.query.startDate ? new Date(req.query.startDate) : null;
      const endDate = req.query.endDate ? new Date(req.query.endDate) : null;
      const userId = req.query.user || null;
      const giftCardId = req.query.giftCard || null;
      const referenceCode = req.query.referenceCode?.trim() || null; // NEW
  
      // Build query
      const filter = {};
  
      // Date range
      if (startDate || endDate) {
        filter.purchasedAt = {};
        if (startDate) filter.purchasedAt.$gte = startDate;
        if (endDate) filter.purchasedAt.$lte = endDate;
      }
  
      // Filters by related IDs
      if (userId) filter.user = userId;
      if (giftCardId) filter.giftCard = giftCardId;
  
      // Reference code search (case-insensitive, exact or partial)
      if (referenceCode) {
        filter.paymentReferenceCode = { $regex: new RegExp(referenceCode, 'i') };
      }
  
      // Count
      const totalOrders = await Order.countDocuments(filter);
  
      // Fetch orders
      const orders = await Order.find(filter)
        .populate('user', 'name email')
        .populate('giftCard', 'brand value')
        .sort({ [sortField]: sortOrder })
        .skip((page - 1) * limit)
        .limit(limit);
  
      // Respond
      res.json({
        orders,
        totalOrders,
        totalPages: Math.ceil(totalOrders / limit),
        currentPage: page,
      });
  
    } catch (error) {
      console.error('Error fetching orders:', error);
      res.status(500).json({ message: 'Server error' });
    }
  };

exports.uploadPaymentProof = async (req, res) => {
    try {
        const { orderId } = req.params;
        const { transactionId } = req.body;
        // Assuming you're using multer for file upload middleware
        const fileUrl = req.file ? `/uploads/payments/${req.file.filename}` : null;

        const order = await Order.findById(orderId);
        if (!order) return res.status(404).json({ message: 'Order not found' });
        if (!order.user.equals(req.user._id) && req.user.role !== 'admin') {
            return res.status(403).json({ message: 'Not authorized' });
        }
        if (order.paymentStatus !== 'pending_payment' && req.user.role !== 'admin') {
            return res.status(400).json({ message: 'Payment proof not needed for this order' });
        }

        order.paymentProof = {
            url: fileUrl,
            transactionId
        };
        order.paymentStatus = 'payment_review';
        await order.save();

        res.json({ message: 'Payment proof uploaded successfully', order });
    } catch (error) {
        console.error('Upload payment proof error:', error);
        res.status(500).json({ message: 'Server error' });
    }
};

exports.verifyPayment = async (req, res) => {
    try {
        const { orderId } = req.params;
        const { status } = req.body; // 'approved' or 'rejected'

        const order = await Order.findById(orderId).populate('giftCard').populate('user');
        if (!order) return res.status(404).json({ message: 'Order not found' });

        if (status === 'approved') {
            order.paymentStatus = 'paid';
            order.status = 'completed';
            order.purchasedAt = new Date();
            order.paidAt = new Date();

            // TODO: trigger sendGiftCode(order)
        } else if (status === 'rejected') {
            order.paymentStatus = 'cancelled';
            order.status = 'cancelled';
        }

        await order.save();

        res.json({ message: `Order payment ${status}`, order });
    } catch (error) {
        console.error('Verify payment error:', error);
        res.status(500).json({ message: 'Server error' });
    }
};

exports.viewPaymentProof = async (req, res) => {
    const order = await Order.findById(req.params.orderId);
    if (!order) return res.status(404).json({ message: 'Order not found' });
    if (!order.user.equals(req.user._id) && req.user.role !== 'admin') {
        return res.status(403).json({ message: 'Not allowed' });
    }
    res.json({ paymentProof: order.paymentProof });
};